//
// this is is a test of a Stream
//   the Stream does numeric integration in chunks of intervals
//   partial sums are generated by the producer
//   the consumer of the stream sums the partial sums and reports the result
//

#include <stdio.h>
#include <stdlib.h>

#include "EventLoop.h"
#include "Stream.h"

// "box" a double
typedef struct {
  double value;
} Double;

// global for use by the two handlers
static double sum = 0.0;
static double width;
static void *gEventLoop;
static void *gStream;

// handler for the "data" event
//how I would do it
/* void processValue(void *arg){
   double val=(double)arg;
   sum+=arg;
   }
*/
static void processValue(void *arg){
  sum += ((Double *) arg)->value;

  free(arg);
}

// handler for the "end" event
static void terminate(void *arg)
{
  printf("Pi is %f\n", sum * width);

  cleanupStream(gStream);
  stopEventLoop(gEventLoop);
}

// used to pass two values to piInit
typedef struct {
  int totalChunks;
  int chunkSize;
} PiParams;

// used to maintain state between calls to the "produce" function
typedef struct {
  int totalChunks;
  int chunkSize;
  double width;
  int nextChunk;
} PiState;

// initialize the Pi computation
//   expects two params:
//     totalChunks: how many chunks of intervals to use in numeric integration
//     chunkSize: how many intervals per chunk
//     so the total number of intervals used will be totalChunks * chunkSize
static void *piInit(void *piParams)
{
  PiParams *p = piParams;
  PiState *ret = malloc(sizeof(PiState));
  if (ret == NULL)
  {
    fprintf(stderr, "malloc failed in piInit\n");
    exit(-1);
  }
  ret->totalChunks = p->totalChunks;
  ret->chunkSize = p->chunkSize;
  ret->width = 1.0 / (p->totalChunks * p->chunkSize);
  width = ret->width;
  ret->nextChunk = 0;

  free(p);
  return ret;
}

// do one slice (chunk of intervals) of the Pi calculation
static void *piSlice(void *piState)
{
  PiState *p = piState;
  int i = p->nextChunk;
  if (i >= p->totalChunks)
  {
    // okay, to free the Pi state
    free(p);
    return NULL;
  }
  else
  {
    p->nextChunk += 1;
    int start = i * p->chunkSize;
    int nextStart = (i + 1) * p->chunkSize;
    double sum = 0.0;
    double x = (start + 0.5) * p->width;
    for (int j = start; j < nextStart; j += 1)
    {
      sum += (4.0 / (1.0 + (x * x)));
      x += p->width;
    }
    Double *ret = malloc(sizeof(Double));
    if (ret == NULL)
    {
      fprintf(stderr, "malloc failed in piSlice\n");
      exit(-1);
    }
    ret->value = sum;
    return ret;
  }
}

// "main" function for the event loop
void computePi(void *eventLoop)
{
  // remember the event loop for use in terminate function
  gEventLoop = eventLoop;

  // create the stream
  void *stream = createStream("data", "end", piSlice, piInit, eventLoop);
  if (stream == NULL)
  {
    fprintf(stderr, "cannot create stream\n");
    exit(-1);
  }

  // remember the stream for use in terminate function
  gStream = stream;

  // create struct for Pi params
  PiParams *p = malloc(sizeof(PiParams));
  if (p == NULL)
  {
    fprintf(stderr, "malloc failed in computePi\n");
    exit(-1);
  }
  p->totalChunks = 1000;
  p->chunkSize = 1000;

  // register event handlers
  registerEvent(eventLoop, "data", processValue);
  registerEvent(eventLoop, "end", terminate);

  // start the stream
  startStream(stream, p);
}

int main()
{
  // create an EventLoop
  void *eventLoop = createEventLoop();
  if (eventLoop == NULL)
  {
    fprintf(stderr, "createEventLoop failed!");
    exit(-1);
  }

  // start it
  startEventLoop(eventLoop, computePi, eventLoop);

  cleanupEventLoop(eventLoop);

  printf("main exiting....\n");

  return 0;
}

