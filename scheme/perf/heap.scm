(use-modules (srfi srfi-9)
             (srfi srfi-43)
             (srfi srfi-11))
;(require srfi/9 srfi/43 srfi/11)
(define-syntax-rule (vector-extend! vec)
  (set! vec (vector-copy vec 0 (* 2 (vector-length vec)))))
(define-syntax-rule (heap-left-child i) (+ 1 (* 2 i)))
(define-syntax-rule (heap-right-child i) (+ 2 (* 2 i)))
(define-syntax-rule (heap-parent i)
  (inexact->exact (floor (/ (- i 1) 2))))
(define-record-type heap
  (make-heap-primitive vector cmp length)
  heap?
  ;;vector needs a setter so we can 
  (vector heap-vector heap-set-vector!)
  (cmp heap-cmp)
  (length heap-length heap-set-length!))
(define-syntax make-heap
  (syntax-rules ()
    ((_ cmp) (make-heap cmp 32))
    ((_ cmp length)
     (make-heap-primitive (make-vector length 0) cmp 0))))
(define-syntax-rule (heap-extend! heap)
  (let ((new-sz (* 2 (heap-length heap))))
    (heap-set-vector! heap
     (vector-copy (heap-vector heap) 0 new-sz))))
(define-syntax-rule (heap-values heap)
  (values (heap-vector heap) (heap-cmp heap) (heap-length heap)))
(define-syntax-rule (heap-push! heap elt)
  (begin
    (vector-set! (heap-vector heap) (heap-length heap) elt)
    (heap-set-length! heap (+ (heap-length heap) 1))))
;;These are convenient but slow
;;(define (heap-ref i (vector-ref (heap-vector i))))
;;(define (heap-set! i elt (vector-set! (heap-vector i elt))))
(define-syntax-rule (heap-size heap)
  (vector-length (heap-vector heap)))
;;Always bind cmp and vec to lexical variables before looping to avoid
;;calling the accessors every time
(define (sift-down vec cmp root end)
  (let loop ((left (heap-left-child root))
             (right (heap-right-child root)) (swap root))
    (when (< left end)
      (when (cmp (vector-ref vec left) (vector-ref vec swap))
        (set! swap left))
      (when (and (< right end)
                 (cmp (vector-ref vec right) (vector-ref vec swap)))
        (set! swap right))
      (when (not (= swap root))
        (vector-swap! vec root swap)
        (set! root swap);;not necessary but makes the next line easier to read
        (loop (heap-left-child root) (heap-right-child root) root)))))
(define (heap-sift-down heap root end)
  (let-values (((vec cmp) (heap-values heap)))
    (sift-down vec cmp root end)))
(define (sift-up vec cmp index)    
  (let loop ((parent (heap-parent index))
             (index index))
    (when (cmp (vector-ref vec index) (vector-ref vec parent))
      (vector-swap! vec index parent)
      (loop (heap-parent parent) parent))))
(define (heap-sift-up heap index)
  (let-values (((vec cmp) (heap-values heap)))
    (sift-up vec cmp index)))
(define (heapify heap)
  (let-values (((vec cmp len) (heap-values heap)))
    (let loop ((start (heap-parent (- len 1))))
      (when (>= start 0)
        (sift-down vec cmp start len)
        (loop (- start 1))))))
;;heap-insert! and heap-pop! don't have loops so we don't
;;need to destructure the heap for speed
(define (heap-insert! heap elt)
  (when (>= (heap-length heap) (heap-size heap))
    (heap-extend! heap))
  (let ((len (heap-length heap)))
    (vector-set! (heap-vector heap) len elt)
    (heap-set-length! heap (+ len 1))
    (heap-sift-up heap len)))
(define (heap-pop! heap)
  (let* ((vec (heap-vector heap))
         (ret (vector-ref vec 0))
         (len (- (heap-length heap) 1)))
    (heap-set-length! heap len)
    (vector-set! vec 0 len)
    (heap-sift-down heap 0 len)
    ret))
(define (heap-sort! heap)
  (if (<= (heap-length heap) 1)
      heap
      (let-values (((vec cmp len) (heap-values heap)))
        (heapify heap)
        (let loop ((end (- len 1)))
          (when (> end 0)
            (vector-swap! vec end 0)
            (sift-down vec cmp 0 end)
            (loop (- end 1)))))))

