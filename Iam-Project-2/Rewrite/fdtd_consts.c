/* generate compile time constants.
 * Allows the user to decide the physical parameters of 
 * the simulation, but also allows optimization because 
 * constants are known at compile time, rather than 
 * waiting until runtime to initialize them*/
#include <stdio.h>
#include <x86intrin.h>
#include <getopt.h>
#define M_PI 3.1415926535897931
#define opttol() strtol(optarg,NULL,10)
#define opttod() strtod(optarg,NULL)
const double episilon_0 = 8.854187e-12;
const double mu_0 = M_PI*4e-7;
static const char* help = "Usage: gen_consts [args]\nArgs:"
  "threads|j INT, number of threads to use, currently does nothing\n"
  "grid_x|x grid_y|y grid_z|z  INT, maximum x/y/z value on the grid"
  "defaults to 20x20x20\n"
  "\tbecause the grid must be symmetric also defines the minimum value\n"
  "mu|u DOUBLE magnetic permeability of the grid, defaults to mu_0\n"
  "sigma|s DOUBLE, conductivity of the grid, defaults to 1e7(~iron)\n"
  "episilon|e DOUBLE, electric permittivity of the grid, defaults to episilon_0\n"
  "delta_x|d DOUBLE, spacial step of the grid, dx = dy = dz, defaults to 1\n"
  "\tused to scale grid size so that the step equals one,time step = (3/dx^2)^1/2\n"
  "num_mesurements|m INT, how many times to record dat, defaults to 10\n"
  "\tmeasurements are taken at equaly spaced time intervals\n"
  "help|h, display this help and exit";
FILE* consts;
const char* prefix ="/* This file is automatically generated, do not edit */\n"
"#ifndef __FDTD_CONSTS_H__\n"
"#define __FDTD_CONSTS_H__\n";
const char* suffix ="#endif";
int main(int argc,char* const argv[]){
  int c;
  int digit_optind = 0;  
  int grid_x=20,grid_y=20,grid_z=20,threads_temp=3,write_num=5;
  double mu=mu_0,episilon_temp=episilon_0,sigma_temp=0,dx=1;
  double t=0,t_max=30;
  int option_index = 0;
  static struct option long_options[] = {
    {"threads", required_argument, 0,  'j' },
    {"grid_x",  required_argument, 0,  'x' },
    {"grid_y",  required_argument, 0,  'y' },
    {"grid_z",  required_argument, 0,  'z' },
    {"mu",      required_argument, 0,  'u' },
    {"sigma",   required_argument, 0,  's' },
    {"episilon",required_argument, 0,  'e' },
    {"delta_x" ,required_argument, 0,  'd' },
    {"num_mesurements",required_argument, 0, 'm'},
    {"help",0,0,'h'},
    {0,         0,                 0,   0  }
  };
  while (1) {
    c = getopt_long(argc, argv, "j:x:y:z:u:s:e:d:m:h",
                    long_options, &option_index);
    if (c == -1){break;}    
    switch (c) {
      case 'j':
        threads_temp=opttol();
        break;
      case 'x':
        grid_x=opttol();
        break;
      case 'y':
        grid_y=opttol();
        break;
      case 'z':
        grid_z=opttol();
        break;
      case 'u':
        mu=opttod();
        break;
      case 's':
        sigma_temp=opttod();
        break;
      case 'e':
        episilon_temp=opttod();
        break;
      case 'd':
        dx=opttod();
        break;
      case 'm':
        write_num=opttol();
        break;
      case 'h':
        puts(help);
        return;
    }
  }
  //need to decide on how to deal with dx/dt, do I scale them away 
  //for programming convience, or keep them so data makes more sense
  FILE* consts = fopen("fdtd_consts.h","w");
  fputs(prefix,consts);
  fprintf(consts,"static const double dx = %f;\n",dx);
  fprintf(consts,"static const int num_writes = %d;\n",write_num);
  fprintf(consts,"static const int threads = %d;\n",threads_temp);
  fprintf(consts,"static const double mu = %16.16f;\n",mu);
  fprintf(consts,"static const double episilon = %16.16f;\n",episilon_temp);
  fprintf(consts,"static const double sigma = %f;\n",sigma_temp);
  fprintf(consts,"static const int x_max = %d;",(int)(grid_x/dx));
  fprintf(consts,"static const int x_min = %d;\n",(int)(-grid_x/dx));
  fprintf(consts,"static const int y_max = %d;",(int)(grid_y/dx));
  fprintf(consts,"static const int y_min = %d;\n",(int)(-grid_y/dx));
  fprintf(consts,"static const int z_max = %d;",(int)(grid_z/dx));
  fprintf(consts,"static const int z_min = %d;\n",(int)(-grid_z/dx));
  fprintf(consts,"static const double dt = 1;\n");
    //sqrt(3*(1/pow(dx,2)));//or probably dt = 1
  fprintf(consts,"static const int grid_size = %d;\n",
          (2*grid_x)*(2*grid_y)*(2*grid_z));
  fprintf(consts,"static const double mu_dt = %16.16f;\n",mu);
#ifdef __x86_64__
  fputs("#include <x86intrin.h>\n#ifdef __AVX__\n",consts);
  fprintf(consts,"static const  __m256d mu_dt_simd = {%f,%f,%f,%f};\n",
          mu,mu,mu,mu);
  fputs("#endif\n",consts);
#endif
  fputs(suffix,consts);
}
