\documentclass{article}
\usepackage{mathtools,fullpage,graphics,amsfonts,mdwlist}
\author{Tucker DiNapoli}
\title{A 2-D Parallel Finite Difference Time Domain Solver Using MPI}
\begin{document}
\maketitle
\section{Introduction}
This project aimed to develop a parallel implementation of a two dimensional
finite difference time domain(FDTD) solver implemented in C using mpi. The
primary goal of the project was the implementation of parallization using MPI,
so much of the base FDTD code was taken from other open source FDTD solvers.
The project thus consisted of two major parts, adapting the existing code(much
of which was written in C++) and parallelizing the code with MPI.
\section{Scientific Background}
The finite difference time domain technique is a method used to model the
behavior of electric and magnetic fields. As the name suggests FDTD uses finite
differences (in space and time) to determine the time evolution of the
system. FDTD uses a rectangular grid composed of some number of cubes each with
an area of d\(x^3\) (or squares of area d\(x^2\) in a 2-D problem) to represent
the spacial extent of the problem. In order to account for different types of
objects the values used for electromagnetic permittivity and permeability can
be chosen separately for each cell. FDTD works by setting the values of each of
these cells according to a given initial condition and updating the values in
each cell using Maxwell's equations, with the time derivatives replaced by
finite differences. The boundary conditions are usually accounted for using a
technique named Perfectly Matched Layers(PML) where the physical properties of
the boundaries are chosen such that all incoming waves are absorbed.
%what problem does fdtd solve
\section{Numerical Analysis}
FDTD is just one of the computational techniques used in modeling
electromagnetic fields, and is one of the earliest used. FDTD is still used
today because of the relative simplicity of implementing it and the fact that
it is much less resource intensive that other methods. That said FDTD has its
flaws, it tends to be less accurate that other commonly used methods and as a
result of the rectangular grid it does not deal well with problems involving
spherical objects or geometries. Also because FDTD is an iterative method it is
only practical to use from modeling the fields near the source.  Numerically
FDTD is relatively simple, once the characteristics of the grid are chosen a
time step must be chosen such that \(\Delta t < \sqrt{3\Delta x^2}\). The
updating of the grid is done in such a manner that the fields in each node can
be updated independently then information about the magnetic fields is
transferred between adjacent cubes, this information is used to update the
nodes at the next time step. This process is repeated for a set number of steps
to generate the required data.
%how how do we do fdtd
\section{Code}%maybe a better name
%quick intro
As there are dozens of preexisting implementations of FDTD methods in a variety
of programming languages, many of which are open source, this project focused
on taking a pre-existing 2-D FDTD implementation in C++, translating it to C
and parallelizing it using mpi.
\subsection{Existing Implementations}
There are many open source FDTD programs, many of which are written in C++, and
few of which are optimized for parallel processing (notable exceptions include
angora and meep). A few notable implementations are OpenEMS, a 3-D FDTD solver
written in c++ and with a matlab/octave interface, meep parallel 2-D 3-D solver
written in C++ which is a project of MIT and angora a 3-D solver in C++
parallelized using MPI.  The basic code used in this project was taken from
EMWave2D an FDTD solver in C++ licensed under the GNU public license. Much of
the ideas for the parallization were taken from the aforementioned angora.
\subsection{Code Adaptation}
The first step in this project was translating the C++ code into C code and
removing any unnecessary sections of code. The choice of C over C++ is mainly
based on personal reference, C++ offers some features C does not but C
programs consistently run faster that equivalent C++ programs. Many of the more
complicated solvers (the three previously mentioned meep,angora and openems)
make heavy use of C++ specific features and libraries to the point it would be
unfeasible to adapt them to C. The code that was used (from EMWave2D) was for
the most part essentially C code, with the exception of a gui that was
implemented, however as only the numerical code was needed almost no
modification actually had to be done to the code beyond removing the unnecessary
sections.
%what code did I adapt and what did I do
\subsection{Parallelization}
The FDTD method is embarrassingly parallel, the majority of calculations can be
done in parallel with the only exchange of data being the transfer of H-field
components between adjacent cells. There several conceivable means of
parallelizing the FDTD algorithm depending on the degree of scaling needed  and
parallization required. The main loop of the FDTD algorithm is basically:\\
For each cell in the grid
\begin{enumerate*}
\item Update E field
\item Update E field at boundary
\item Update H field
\item Update H field at boundary
\item Exchange H field information with neighboring cells
\item Step time
\end{enumerate*}
As can be seen only the fifth step requires any communication between
cells. The method used in angora(and this project) takes full advantage of the
FDTD algorithm to create a means of parallization that is both scale able and
efficient. Essentially what is done is to create a set of MPI communicators for
each node to transfer H field information to its neighbors. These communicators
are created first by splitting MPI\_COMM\_WORLD into n subcommunicators where n
is the total number of processes. These subcommunicators are then orginized
into Cartesian topology (akin to the way the FDTD grid itself is orginized)
using MPI\_Cart\_create. When necessary the H fields are updated by sending
data between nodes using MPI\_Sendrecv to send data. The data sent is based on
the topology with the specific coordinates determined by using
MPI\_Cart\_cords. The process varies slightly for the boundary elements because
of the added complexity of the PMLs but this simply adds complexity during the
computation, all that is necessary for parallelization is to note that the
boundary elements have less information to transfer.

%what did I do generically(ie what parts did I split up)
%where did i need to transfer info etc
%Then How did I do this via mpi
\section{Data}
As of the time of this report the code for this project is unfinished. Much of
the organization of code and outlining of the parallelization is finished but
much of the complex code involved in boundary conditions and material
properties is unfinished. The complexity of these sections of the code was
underestimated and thus there was not enough time to complete them. Time was
spent mostly on understanding the parallelization and theory and thus the
practical difficulties were not accounted for. In place of actual data will be
a review of the techniques used and how the generic technique behind FDTD would
be done.

The implementation of a generic algorithm similar to FDTD implemented using the
techniques used/studied in this project would be as follows. Firstly we would
assume a heterogeneous medium as much of the complexity of FDTD comes from the
material parameters. A two dimensional grid is created of some size NxM
composed of NxM/dx squares of area d\(x^2\). The grid is initialized using a
given initial conditon,a simple example would be to have a blank grid and some
source at the center which would be turned on at the first time step. This is a
technique often used in FDTD, for example to model the propagation of waves
generated by an antenna. Parallelization would be implemented via the scheme
proposed above. A simple absorbing boundary condition would be implemented
rather than the more complicated PML conditon. The program would then run for a
set amount of time, with data being recorded at set intervals, based on the
length of time and the size of the time step. Once the simulation has finished
the data could be animated to show the time evolution of the system.
%hopefully show an example use of my code, try and do some profiling
%Also do some examples of how does the parallization speed up the code
\section{Conclusion}
It is hard to reach a conclusion as much of the project is unfinished, but some
important ideas can be understood from the work that was done. The largest
issue with this project was clearly that the scope was too large, while the
basic numerical methods of FDTD are fairly simple, there are many complications
in dealing with different initial conditions, material properties and boundary
conditions. Work with FDTD programs was used as a benchmark for estimating the
difficulty, and while understanding FDTD is complex in and of itself it is not
unreasonably complex. However the gap between understanding and actually
implementing the technique was too broad. What likely should have been done was
to select a problem similar in technique (a problem involving a two dimensional
grid with finite differences used to estimate derivatives) without the added
complexity of the material characteristics and boundary conditions of FDTD
which would be implemented as shown above. This project will continue to be
worked on, likely starting over as proposed, though there will be no set
deadline it is hoped that a successful program will be written at some point.
\end{document}
