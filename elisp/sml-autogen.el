;;blocks, i.e. structures,signatures,functors,etc
(defmacro sml-insert-block (fun-name block-name block-abbr)
  `(progn(cl-defun ,fun-name (name body &optional (sml-buffer (current-buffer)))
           (princ (format "\n%s %s =\n%s" ,block-name name ,block-abbr) sml-buffer)
           (princ body sml-buffer)
           (princ "\nend" sml-buffer))))
(defmacro sml-string-block (fun-name block-name block-abbr)
  `(progn(defun ,fun-name (name &rest body)
           (concat (cl-loop for i in 
                            (cons (format "\n%s %s =\n%s\n" ,block-name name ,block-abbr) body)
                            concat i)
           "\nend"))))
(sml-string-block sml-string-functor "Functor" "")
(sml-insert-block sml-functor "Functor" "")
(sml-string-block sml-string-struct "Structure" "struct")
(sml-insert-block sml-struct "Structure" "struct")
;; (defmacro sml-autogen-define (name block-name block-abbr)
;;   `(progn
;;      (sml-string-block sml-string-,name ,block-name ,block-abbr)
;;      (sml-insert-block sml-,name ,block-name ,block-abbr)))
;; (sml-autogen-define functor "Functor" "")
;;scope opperators, really just local and let
(cl-defun sml-scope (sml-keyword sml-varlist sml-body &optional (sml-buffer (current-buffer)))
  (princ (format "\n%s\n%s\nin %s end" sml-keyword sml-varlist sml-body) sml-buffer))
;;patterns, functons, conds, handlers etc
(cl-defun sml-pattern (name &rest patterns)
  (princ (format "\n%s %s\n" name (car patterns)))
  (dolist (pattern (cdr patterns))
    (princ (format "  | %s\n" pattern))))
;;records, if first val is non-nil use = as seperator, else use :
(cl-defun sml-records (sml-defn &rest body)
  (let ((seperator "")
        (key-vals body))
    (if (null sml-defn)
      (setq seperator " = ")
      (setq seperator ": "))
    (princ (format "\n{%s%s%s," (pop key-vals) seperator (pop key-vals)))
    (while (not (null (cddr key-vals)))
      (princ (format "\n %s%s%s" (pop key-vals) seperator (pop key-vals))))
    (princ (format "\n %s%s%s}" (pop key-vals) seperator (pop key-vals)))))
